# 安卓常用第三方库的的使用

## Glide

> 项目：summerGlideT

添加依赖

```java
implementation 'com.github.bumptech.glide:glide:4.11.0'
```

添加网络权限

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

### 加载图片

```java
Glide.with(context).load(url).into(imageView);
//举例
Glide.with(this).load(R.mipmap.wangjunkai).into(picture1);
```

各种形式

```java
// 加载本地图片
File file = new File(getExternalCacheDir() + "/image.jpg");
Glide.with(this).load(file).into(imageView);
 
// 加载应用资源 放入资源的id
Glide.with(this).load(R.drawable.image).into(imageView);
 
// 加载二进制流  放入byte数组bytes
Glide.with(this).load(bytes).into(imageView);
 
// 加载Uri对象 放入uri对象
Glide.with(this).load(uri).into(imageView);

//也可以把url存在javabean的集合里面，要用取出来用作load的参数  
```

### 占位图及缓存的使用

在图片加载失败或者加载不出来时可以预设好本地图片呈现给用户

glide库里面封装好了缓存图片的方法，调用diskCacheStrategy可以设置缓存，根据需要传入参数即可

```java
Glide.with(this).load(url)
     .placeholder(R.drawable.loading)//加载资源中有的图片
     .error(R.drawable.error)//加载错误提示的图片
     .diskCacheStrategy(DiskCacheStrategy.NONE)//关闭Glide的硬盘缓存机制
     .into(imageView);
//DiskCacheStrategy.NONE： 表示不缓存任何内容。
//DiskCacheStrategy.SOURCE： 表示只缓存原始图片。
//DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。
//DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。
```

### options的加入

可以在options先设置好各种条件，在加载图片时用apply(options)就可以了

好处：要是多处图片加载一样的效果，可以把options封装起来

（以下的设置都是在options中添加）

```java
//options设置好附加条件
RequestOptions options = new RequestOptions()
              .placeholder(R.drawable.loading)
              .error(R.drawable.error)
              .skipMemoryCache(true)
              .override(100,200)//改变大小，很少用，因为glide会自己根据image大小来加载图片
              .diskCacheStrategy(DiskCacheStrategy.NONE);
Glide.with(context).load(url).apply(options).into(imageView);
//举例
Glide.with(this).load(R.drawable.wangjunkai).apply(options).into(picture1);
```

### 静态图和动图设置

```java
.asBitmap()//加载静态图 如果传入的是动图只会加载第一帧
.asGif()//动图
```

### 图形设计

```java
.circleCrop()//截成圆形
```

![](E:\QG移动组\QG2021暑假训练营\JAVA查漏补缺\图片\Glide  圆形.png)

```java
.centerCrop()//从中心向外扩展形成满足imageView大小的图片
```

![](E:\QG移动组\QG2021暑假训练营\JAVA查漏补缺\图片\Glide中间向外.png)

### 图片效果设置



### 动画设置

```java
//默认设置淡入淡出
.dontAnimate()//不加载动画
```



## OkHttp

依赖

```java
implementation 'com.squareup.okhttp3:okhttp:3.5.0' 
```

### Get请求

* 创建OkHttpClient对象
* 创建request对象 设置网址等等
* 调用execute()返回数据
* 转为字符串返回

```java
public class NetWorkUtils {
    public static String sendRequestWithOkHttp(String url) {
        String responseData = null;
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            responseData = response.body().string();
            Log.d("NetWorkUtils","sendRequestWithOkHttp: "+responseData);
        } catch (IOException e) {
            Log.d("NetWorkUtils","网络错误");
            e.printStackTrace();
        }
        return responseData;
    }
}
```

异步操作

* 将request封装为call

* 设置回调函数

```java
OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Call call = client.newCall(request);
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                //返回获取错误的提示
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                //返回成功
                final String res = response.body().string();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        //更新UI
                    }
                });
            }
        });
```



### Post请求

* 与get不同 用FormBody MultipartBody 或者RequestBody构建自己的requestBody

```java
//OkHttp进行Post请求提交键值对
FormBody formBody = new FormBody.Builder()
                .add("username", "admin")
                .add("password", "admin")
                .build();
                
//OkHttp进行Post请求提交字符串
RequestBody requestBody = RequestBody.create(MediaType.parse("text/plain;charset=utf-8"), "{username:admin;password:admin}");

//OkHttp进行Post请求上传文件
File file = new File(Environment.getExternalStorageDirectory(), "1.png");
if (!file.exists()){
    Toast.makeText(this, "文件不存在", Toast.LENGTH_SHORT).show();
}else{
    RequestBody requestBody2 = RequestBody.create(MediaType.parse("application/octet-stream"), file);
}

//OkHttp进行Post请求提交表单
File file = new File(Environment.getExternalStorageDirectory(), "1.png");
if (!file.exists()){
    Toast.makeText(this, "文件不存在", Toast.LENGTH_SHORT).show();
    return;
}
RequestBody muiltipartBody = new MultipartBody.Builder()
        //一定要设置这句
        .setType(MultipartBody.FORM)
        .addFormDataPart("username", "admin")//
        .addFormDataPart("password", "admin")//
        .addFormDataPart("myfile", "1.png", RequestBody.create(MediaType.parse("application/octet-stream"), file))
        .build();
```



```java
public static String sendRequestWithOkHttpPost(String url) {
        String responseData = null;
        OkHttpClient client = new OkHttpClient();
    	//多了requestBody的创建和加入
        RequestBody requestBody = new FormBody.Builder()
                .add("username","admin")//向服务器提交账号密码
                .add("password","123456")
                .build();
        Request request = new Request.Builder()
                .url(url)
                .patch(requestBody)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            responseData = response.body().string();
            Log.d("NetWorkUtils","sendRequestWithOkHttp: "+responseData);
        } catch (IOException e) {
            Log.d("NetWorkUtils","网络错误");
            e.printStackTrace();
        }
        return responseData;
    }
```

### 自定义配置

Builder构建者 

#### 过滤器

* 好处：可以统一配置发出请求前后要加的自定义配置，减少重复代码

```java
public static void okhttpBuilder(String url){
        OkHttpClient okHttpClient = new OkHttpClient.Builder().addInterceptor(new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {
                //前置处理
                Request request = chain.request().newBuilder().addHeader("name","value").addHeader("version","1.0").build();

                Response response = chain.proceed(request);
                //后置处理

                //没有做任何事情，只是过了一遍
                //return chain.proceed(chain.request());
                return response;
            }
        }).build();

        Request request = new Request.Builder().url(url).build();
        //准备好请求的对象
        Call call = okHttpClient.newCall(request);
        try {
            Response response = call.execute();
            Log.d(TAG,response.body().toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

* 优先级

  可以设置多个过滤器（继续链式调用），排序按代码顺序

  addInterceptor优先于addNetWorkInterceptor

#### 缓存

* 介绍：按照http协议实现了缓存的处理，但是默认情况下是关的，要开

* 简单用法  设置缓存路径及最大容量

  ```java
  OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(new Cache(new File("本地文件路径"),100)).build();
  ```

## Gosn

依赖

```java
implementation 'com.google.code.gson:gson:2.8.6'
```

### 基础

* 对象的序列化及反序列化（不管里面嵌套啥）

  ```java
  Gson gson = new Gson();
  Word word = new Word();
  //序列化
  String json = gson.toJson(word);
  //反序列化
  Word word2 = gson.fromJson(json,Word.class);
  ```

* 数组的序列化及反序列化

  把参数转为数组对象即可

* List 

  伪泛型，反序列化时不能判断是什么类型，要借用Type

  ```java
  List<Word> word = gson.fromJson(josnData, new TypeToken<List<Word>>(){}.getType());
  ```

* Map

  ```java
  Map<String,Word> map = new HashMap<>();
  String json = gson.toJson(map);
  Map<String,Word> map2 = gson.fromJson(json,new TypeToken<Map<String,Word>>(){}.getType());
  ```

* Set

  List跟HashSet返回的是一样的  后面对数据进行运用的时候不一样

  ```java
  Set<Word> set = new HashSet<>();
  String json = gson.toJson(set);
  List<Word> set2 = gson.fromJson(json,new TypeToken<List<Word>>(){}.getType());
  Set<Word> set3 = gson.fromJson(json,new TypeToken<Set<Word>>(){}.getType());
  ```

* 注释的运用

  ```java
  //改变变量的名称 
  @SerializedName("word_name")
  private String word;
  //设置是否参与序列化和反序列化 默认都参与
  @Expose(serialize = false,deserialize = false)
  private Integer is_CRI;
  
  //用了Expose注解的话 gson创建要改一下才能让expose生效
  Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
  
  //想要某属性不参与序列化与反序列化的话 可以直接加transient 修饰符
  private transient Integer is_CRI;
  ```

  

### 举例 与OkHttp一起使用

```java
public class NetWorkUtil {
    final static String TAG = "NetWorkActivity";
    public static String sendRequestWithOkHttp(String url) {
        String responseData = null;
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            responseData = response.body().string();
            Log.d("NetWorkUtils","sendRequestWithOkHttp: "+responseData);
        } catch (IOException e) {
            Log.d("NetWorkUtils","网络错误");
            e.printStackTrace();
        }
        return responseData;
    }

    public static Word jsonExchange(String json){
        Gson gson = new Gson();
        Log.d(TAG,json);
        Word word = gson.fromJson(json,Word.class);
        Log.d(TAG,word.getWord()+word.getIs_CRI());
        return word;
    }
    public static List<Word> jsonExchangeList(String json){
        List<Word> words = new ArrayList<>();
        Gson gson = new Gson();
        words = gson.fromJson(json,new TypeToken<List<Word>>(){}.getType());
        return words;
    }
}

```

## Room

项目：summerRoom

文档查询 Developers->Jetpack->room

### 添加依赖

```java
dependencies {
    def room_version = "2.3.0"

    implementation "androidx.room:room-runtime:$room_version"
    annotationProcessor "androidx.room:room-compiler:$room_version"

    // optional - RxJava2 support for Room 暂时不需要
    implementation "androidx.room:room-rxjava2:$room_version"

    // optional - RxJava3 support for Room  暂时不需要
    implementation "androidx.room:room-rxjava3:$room_version" 

    // optional - Guava support for Room, including Optional and ListenableFuture 暂时不需要
    implementation "androidx.room:room-guava:$room_version"

    // optional - Test helpers
    testImplementation "androidx.room:room-testing:$room_version"
}
```

### 三大角色的介绍

Room是对SQlite的封装，包含三大角色 表，操作数据库，数据库

```java
@Entity //表示实体类  加上注解就变成了一张表
public class Word {}

@Dao //DataBase access object 操作数据库
public interface WordDao {}

@Database(entities = {Word.class},version = 1,exportSchema = false)
//第一个参数有多个实体类可以用逗号隔开，第二个是数据库版本，
public abstract class WordDataBase extends RoomDatabase{}
```

### 三大角色的实现

实体类 Word

#### 实体类简单实现

```java
package com.qg.summerroom;

import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.PrimaryKey;

//自定义表名（默认是类名）
//@Entity(tableName = "users")
//使用复合主键
//@Entity(primaryKeys = {"firstName", "lastName"})
@Entity //表示实体类
public class Word {
    @PrimaryKey(autoGenerate = true)//标记id为主键，让系统自动生成
    private int id;

    @ColumnInfo(name = "English Word")//起个列名便于记忆，不起默认变量名
    private String word;
    @Ignore//忽略字段
    private String chineseMeaning;
	//如果继承了父类实体的字段
    //@Entity(ignoredColumns = "picture")
    public Word(String word, String chineseMeaning) {
        this.word = word;
        this.chineseMeaning = chineseMeaning;
    }

    public String getWord() {
        return word;
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getChineseMeaning() {
        return chineseMeaning;
    }

    public void setChineseMeaning(String chineseMeaning) {
        this.chineseMeaning = chineseMeaning;
    }
}

```

#### 定义对象之间的关系

* 创建嵌套对象  @Embedded

  ```java
      public class Address {
          public String street;
          public String state;
          public String city;
  
          @ColumnInfo(name = "post_code") public int postCode;
      }
  
      @Entity
      public class User {
          @PrimaryKey public int id;
  
          public String firstName;
  
          @Embedded public Address address;
      }
  ```

* 定义一对一关系

  ```java
      public class UserAndLibrary {
          @Embedded public User user;
          @Relation(
               parentColumn = "userId",
               entityColumn = "userOwnerId"
          )
          public Library library;
      }
  //查询@Transaction  需要 Room 运行两次查询
      @Transaction
      @Query("SELECT * FROM User")
      public List<UserAndLibrary> getUsersAndLibraries();
      
      
  ```

  

#### 接口 WordDao

```java
package com.qg.summerroom;

import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.Query;
import androidx.room.Update;

import java.util.List;

/**
 * @Name：SummerRoom
 * @Description：
 * @Author：Suzy.Mo
 * @Date：2021/7/19 10:12
 */
@Dao //DataBase access object 表示访问数据库的接口
public interface WordDao {
    @Insert//插入
    void insertWord(Word... words);

    @Update//更新 int 返回修改了几条记录
    void updateWord(Word... words);

    @Delete//删除  
    void deleteWord(Word... words);

    @Query("DELETE FROM WORD")//清空  Query不仅是查询 更高级：可以增删改查
    void deleteAllWord(Word... words);

    @Query("SELECT * FROM WORD ORDER BY ID DESC")//查询哪张表，选择排序方式，DESC降序
    List<Word> getALLWords(Word... words);
    
    //指定查询规则
    @Query("SELECT * FROM user WHERE age > :minAge")
    public User[] loadAllUsersOlderThan(int minAge);
    
    //指定多个查询规则 且/或
    //"SELECT * FROM 表名 WHERE 变量名 BETWEEN :参数一 AND :参数二"
    //"SELECT * FROM user WHERE first_name LIKE :search " +
    //            "OR last_name LIKE :search"
    @Query("SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge")
    public User[] loadAllUsersBetweenAges(int minAge, int maxAge);
     @Query("SELECT * FROM user WHERE first_name LIKE :search " +
               "OR last_name LIKE :search")
     public List<User> findUserWithName(String search);
    
    //传递参数的集合 可以查询多个条件并返回集合
    @Query("SELECT first_name, last_name FROM user WHERE region IN (:regions)")
        public List<NameTuple> loadUsersFromRegions(List<String> regions);
}
```

#### 抽象类 DataBase

```java
package com.qg.summerroom;

import android.content.Context;

import androidx.room.Database;
import androidx.room.Room;
import androidx.room.RoomDatabase;

@Database(entities = {Word.class},version = 1,exportSchema = false)
//第一个参数有多个实体类可以用逗号隔开，第二个是数据库版本
public abstract class WordDataBase extends RoomDatabase{

    //单例模式  返回DB
    private static WordDataBase INSTANCE;
    static synchronized WordDataBase getInstance(Context context){
        if (INSTANCE == null){
            INSTANCE = Room.databaseBuilder(context.getApplicationContext(),WordDataBase.class,"word_database")
                    //默认是异步线程
                    //慎用 强转开启主线程也可以操作(测试可以用)
                    //.allowMainThreadQueries()
                    .build();
        }
        return INSTANCE;
    }

    //用户只需要操作Dao，要暴露Dao，dao被用户拿到后就可以对数据库进行增删改查
    //多个Entity，则多写个Dao
    public abstract WordDao getWordDao();
}

```

