## 自动包装

基本类型 <=> 包装类型



* 调用方法
* 赋值



**int -> Interger**

**char-> Character**

所有包装类都实现了：

`Comparable<T>` `Constable` 和 `ConstantDesc`

包装类作用：泛型、反射

## 泛型

泛型协变，泛型逆变

* `<? extend x>` 

  接收的泛型：x或者x的子类

  代价：无法确定以 T 为参数的方法应该传入的类型 ( x 的哪一个子类 )，不能调用

* `<? super x>`

  接收的泛型：x或者x的父类

  代价：无法确定以 T 为返回值的方法的返回值类型 ( x 的哪一个父类 )，（ 能强转成 Object ）

## 反射

ClassPath ： package

获取 Class 对象的方法：

* 方法 `methord.getClass()`
* 静态方法 `Class.forName(package.ClassName)`
* 语法 `ClassName.class`

Method 对象： 方法签名 `[returnType] name(ParameterTypes)`

Constructor 对象：构造函数签名

Field 对象：变量类型 + 名字

## Constructor

通过 Class 获取构造函数  Constructor 对象

* `Class.getConstructor(Class<?>... parameterTypes)`(根据参数拿)

```java
Class<Main> clazz = Main.class;
Constructor<Main> c = clazz.getConstructor(int.class);

//通过构造函数拿到对象
Main a = c.newInstance();
```

​	用处举例：根据用户输入实例化不同的类

​	根据用户输入拼字符串，Class.forName(package.ClassName)

​    Ex 一个接口需要实现run方法， 有两个实现类，输入对应类名

```java
Class<?> exClass = Class.forName(com.qg.ex.ClassName);
Ex ex = (Ex)exClass.getConstructor().newInstance();
ex.run();
```



* `class.getCpmstrictors()`（拿到的是数组）

## Method

**方法签名**(把方法名和字符串映射起来)

通过 Class 获取一个 Method 对象

* `Class.getMethod(String MethodName, Class<?>... parameterTypes)`
* `Class.getMethods()`
* `Class.getDeclaredMethod(String MethodName, Class<?>... parameterTypes))`
* `Class.getDeclaredMethods()`

执行方法：

`Method.invoke(Object receiver, Object... parameterTypes)`

**Method 只代表方法签名，最终执行哪个方法要看传入的 receiver**

```java
Methord fun1 = clazz.getDeclaredMethod("fun",int.class);
fun1.setAccessible(true);

fun1.invoke(main,5);
```



## Field(成员变量)

* `Class.getField(String fieldName)`
* `Class.getFields()`

* `Class.getDeclaredField(String fieldName)`
* `Class.getDeclaredFields()`

setter/getter

* `Field.set(Object receiver, Object value)`
* `Field.get(Object receiver)`

```java
Field lield = clazz.getField("a");
field.set(c,1);
```



## 注解

```java
@Retention(RetentionPolicy.RUNTIME) // 可见度
@Target(ElementType.METHOD) // 注解位置
public @interface MyAnnotation {

    int i(); // 参数
    String key() default "Tag"; // 带默认值
}
```

可以加到方法上，类上，变量名上

获取注解：

* `Method.getAnnotation(Class annotationType)`
* `Method.getAnnotations()`

与反射结合使用

```java
@MyAnnotation(i = 4)
public void print(int a){
    System.out.print(a);
}

Main main = new Main();

Methord methord = clazz.getDeclaredMethod("print",int.class);//获得方法
MyAnnotation anntation = methord.getAnnotation(Myanntation.class);//获得注解
int i = anntation.i();//可以拿到注解里面的参数
methord.invoke(main,1);
```

room 通过注解注入Sqlite语句 返回给反射那一方 进行执行

## 动态代理

`Proxy.newProxyInstance`

```java
public static class Main{

        public interface A{
            void a();
        }
        public interface B{
            void b();
        }

        public static void main(String[] args) {
            A a = (A) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
                    new Class[]{A.class, B.class}, new InvocationHandler() {
                        @Override
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            //proxy是类，method是里面的方法，args是里面的变量
                            //可以拿来用
                            //method.invoke(proxy,args);
                            return null;
                        }
                    });
            //a这个对象是同时继承了两个类 强转一下就可以用了
            a.a();
            B b = (B)a;
            b.b();
        }
    }
```



* Retrofit
* Room